# A0143641M
###### \java\seedu\taskmanager\logic\commands\DeleteCommand.java
``` java
    /**
     * Deletes events, tasks, or deadlines by a single index or ascending multiple indexes.
     */
    @Override
    public CommandResult execute() {
        
        if(!hasMultipleIndexes){

            UnmodifiableObservableList<ReadOnlyItem> lastShownList = model.getFilteredItemList();
            if (lastShownList.size() < targetIndex) {
                indicateAttemptToExecuteIncorrectCommand();
                return new CommandResult(Messages.MESSAGE_INVALID_ITEM_DISPLAYED_INDEX);
            }

            ReadOnlyItem itemToDelete = lastShownList.get(targetIndex - 1);
            
            try {
                model.deleteItem(itemToDelete, String.format(MESSAGE_DELETE_ITEM_SUCCESS, itemToDelete));
            } catch (ItemNotFoundException pnfe) {
                assert false : "The target item cannot be missing";
            }
            
            return new CommandResult(String.format(MESSAGE_DELETE_ITEM_SUCCESS, itemToDelete));
        }

        else {
            UnmodifiableObservableList<ReadOnlyItem> lastShownList = model.getFilteredItemList();
            ListIterator<ReadOnlyItem> lslIterator = lastShownList.listIterator();
            int numItemsDeleted = 0;
            
            for(int index : targetIndexes) {
                
                if (lastShownList.size() < (index-numItemsDeleted)) {
                    indicateAttemptToExecuteIncorrectCommand();
                    return new CommandResult(Messages.MESSAGE_INVALID_ITEM_DISPLAYED_INDEX);
                }
                
                // reset iterator to point to first object when reach the end of list
                if(lslIterator.nextIndex() >= lastShownList.size()) {
                    lslIterator = lastShownList.listIterator();
                }

                while(lslIterator.nextIndex() != (index - numItemsDeleted - 1)) {
                    if(lslIterator.nextIndex() > index) {
                        lslIterator.previous();
                    } else if(lslIterator.nextIndex() < (index - numItemsDeleted - 1)) {
                        lslIterator.next();
                    }
                }

                ReadOnlyItem itemToDelete = lastShownList.get(lslIterator.nextIndex());
                    
                try {
                    model.deleteItem(itemToDelete, String.format(MESSAGE_DELETE_ITEM_SUCCESS, itemToDelete));
                } catch (ItemNotFoundException pnfe) {
                    assert false : "The target item cannot be missing";
                }
                
                numItemsDeleted += 1;
                deletedItems.add(itemToDelete);

            }
            
            StringBuilder printResult = new StringBuilder(MESSAGE_DELETE_ITEM_SUCCESS);
            
            for(ReadOnlyItem item : deletedItems) {
                printResult.append(item.toString());
            }
            
            return new CommandResult(String.format(MESSAGE_DELETE_ITEM_SUCCESS, deletedItems));
        }
    }
}
```
###### \java\seedu\taskmanager\logic\commands\SaveCommand.java
``` java
/**
 * Saves the program data file at the specified location in a .xml file.
 */
public class SaveCommand extends Command {
    public static final String COMMAND_WORD = "save";
    
    public static final String MESSAGE_ERROR_CONVERTING_FILE = "Error reading from config file: " + Config.DEFAULT_CONFIG_FILE;
    public static final String MESSAGE_SUCCESS = "File path changed! Custom file path specified: %1$s";
    public static final String MESSAGE_ERROR_SAVING_FILE = "Error occured saving to file.";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Saves task manager information to the specified storage file path.\n"
            + "Parameters: " + COMMAND_WORD + " FILEPATH.xml \n"
            + "Example: " + COMMAND_WORD +  " " + " data/newtaskbook.xml" + "\n"
            + "Note: file path is limited to .xml format";
    
    private static final Logger logger = LogsCenter.getLogger(SaveCommand.class);

    private String newTaskManagerFilePath;

    public SaveCommand(String newTaskManagerFilePath) {
        this.newTaskManagerFilePath = newTaskManagerFilePath;
        logger.info("New task file path specified: " + newTaskManagerFilePath);
    }
    
    @Override
    public CommandResult execute() {
        String defaultConfigFilePath = Config.DEFAULT_CONFIG_FILE;
        
        try {
            Config currentConfig = ConfigUtil.readConfig(defaultConfigFilePath).orElse(new Config());

            String previousFilePath = currentConfig.getTaskManagerFilePath();
            
            currentConfig.setTaskManagerFilePath(newTaskManagerFilePath);
            ConfigUtil.saveConfig(currentConfig, defaultConfigFilePath);
            
            StorageManager previousStorage = new StorageManager(previousFilePath, currentConfig.getUserPrefsFilePath());
            StorageManager newStorage = new StorageManager(newTaskManagerFilePath, currentConfig.getUserPrefsFilePath());
            
            ReadOnlyTaskManager previousTaskManager = previousStorage.readTaskManager().orElse(new TaskManager());
            newStorage.saveTaskManager(previousTaskManager);
            
            logger.fine("Saved to specified file path: " + newTaskManagerFilePath);
            
            return new CommandResult(String.format(MESSAGE_SUCCESS, newStorage.getTaskManagerFilePath()));
            
        } catch (DataConversionException e) {
            return new CommandResult(MESSAGE_ERROR_CONVERTING_FILE);
        } catch (IOException e) {
            return new CommandResult(MESSAGE_ERROR_SAVING_FILE);
        }
    }
}
```
###### \java\seedu\taskmanager\logic\parser\Parser.java
``` java
    /**
     * Parses argument in the context of the saveAs specified file command.
     * @param arguments full argument args string
     * @return the prepared command
     */
    private Command prepareSave(String args) {
        args = args.trim();
        if(parseSaveCommandFormat(args)) {
            return new SaveCommand(args);
        }
        
        return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SaveCommand.MESSAGE_USAGE));
    }

    /**
     * Checks valid file path is given as argument for SaveCommand.
     * @param args parameter input by user for save command
     * @return true if parameter is valid
     */
    private boolean parseSaveCommandFormat(String args) {
        return !args.equals("") && args.endsWith(".xml");
    }
```
###### \java\seedu\taskmanager\logic\parser\Parser.java
``` java
        else if(itemIndexesMatcher.matches()) {
            // separate into the different indexes
            args = args.trim();
            ArrayList<String> indexList = new ArrayList<String>(Arrays.asList(args.split("[^0-9]*")));
            
            // remove empty strings from split
            for(Iterator<String> itr = indexList.iterator(); itr.hasNext(); ) {
                String indexString = itr.next();
                if(indexString.equals("")) {
                    itr.remove();
                }
            }
            ArrayList<Integer> indexesToDelete = new ArrayList<Integer>();
            
            for(String indexInList: indexList) {
                Optional<Integer> index = parseIndex(indexInList);
                if(!index.isPresent()) {
                    return new IncorrectCommand(
                            String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
                }
                else {
                    indexesToDelete.add(index.get());
                }
            }
            return new DeleteCommand(indexesToDelete);
```
