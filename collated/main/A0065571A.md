# A0065571A
###### \java\seedu\taskmanager\commons\events\ui\ChangeDoneEvent.java
``` java
    public ChangeDoneEvent() {
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\taskmanager\commons\events\ui\ShortItemPanelSelectionChangedEvent.java
``` java
    private final ReadOnlyItem newSelection;
    private final int newIdx;

    public ShortItemPanelSelectionChangedEvent(ReadOnlyItem newSelection, int newIdx){
        this.newSelection = newSelection;
        this.newIdx = newIdx;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public ReadOnlyItem getNewSelection() {
        return newSelection;
    }
    
    public int getNewIdx() {
        return newIdx;
    }
}
```
###### \java\seedu\taskmanager\logic\commands\AddCommand.java
``` java
    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String itemType, String name, String startDate, String startTime, String endDate, String endTime, List<String> tags)
            throws IllegalValueException {
        assert itemType != null;
        if (itemType == ItemType.DEADLINE_WORD && endTime == null) {
            endTime = DEFAULT_END_TIME;
        }
        if (itemType == ItemType.EVENT_WORD && startTime == null) {
            endTime = DEFAULT_START_TIME;
        }
        if (itemType == ItemType.EVENT_WORD && endTime == null) {
            endTime = DEFAULT_END_TIME;
        }
        assert name != null;
        assert startDate != null;
        assert startTime != null;
        assert endDate != null;
        assert endTime != null;
        assert tags != null;
        
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Item(
                new ItemType(itemType),
                new Name(name),
                new ItemDate(startDate),
                new ItemTime(startTime),
                new ItemDate(endDate),
                new ItemTime(endTime),
                new UniqueTagList(tagSet)
        );
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            model.addItem(toAdd, String.format(MESSAGE_SUCCESS, toAdd));
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueItemList.DuplicateItemException e) {
            return new CommandResult(MESSAGE_DUPLICATE_ITEM);
        }

    }

}
```
###### \java\seedu\taskmanager\logic\commands\DoneCommand.java
``` java
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Mark the item identified by the index number used in the last item listing as done.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_DONE_SUCCESS = "Done Item: %1$s";

    public final int targetIndex;

    /*
     * Deletes deadline, task, or event by keyword.
     */
    public DoneCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyItem> lastShownList = model.getFilteredItemList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_ITEM_DISPLAYED_INDEX);
        }

        ReadOnlyItem itemToEdit = lastShownList.get(targetIndex - 1);
        
        try {
            model.setDone(itemToEdit, String.format(MESSAGE_DONE_SUCCESS, itemToEdit));
        } catch (ItemNotFoundException pnfe) {
            assert false : "The target item cannot be missing";
        }

        return new CommandResult(String.format(MESSAGE_DONE_SUCCESS, itemToEdit));
    }

}
```
###### \java\seedu\taskmanager\logic\commands\NotDoneCommand.java
``` java
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Mark the item identified by the index number used in the last item listing as not done.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_NOT_DONE_SUCCESS = "Not Done Item: %1$s";

    public final int targetIndex;

    /*
     * Deletes deadline, task, or event by keyword.
     */
    public NotDoneCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyItem> lastShownList = model.getFilteredItemList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_ITEM_DISPLAYED_INDEX);
        }

        ReadOnlyItem itemToEdit = lastShownList.get(targetIndex - 1);
        
        try {
            model.setUndone(itemToEdit, String.format(MESSAGE_NOT_DONE_SUCCESS, itemToEdit));
        } catch (ItemNotFoundException pnfe) {
            assert false : "The target item cannot be missing";
        }

        return new CommandResult(String.format(MESSAGE_NOT_DONE_SUCCESS, itemToEdit));
    }

}
```
###### \java\seedu\taskmanager\logic\commands\RedoCommand.java
``` java
    public static final String COMMAND_WORD = "redo";
    public static final String SHORT_COMMAND_WORD = "r";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Redo last action that led to a change in Todo list"
            + "Example: " + COMMAND_WORD;

    public static final String MESSAGE_DONE_SUCCESS = "Redo last undone action: %1$s";
    public static final String MESSAGE_DONE_FAILURE = "Cannot Redo";

    /*
     * Undo last command that led to a change in todo list.
     */
    public RedoCommand() {
    	
    }

    @Override
    public CommandResult execute() {

        String done = model.redoAction();
        // model.updateFilteredListToShowAll();
        if (done != null) {
            return new CommandResult(String.format(MESSAGE_DONE_SUCCESS, done));
        } else {
            return new CommandResult(MESSAGE_DONE_FAILURE);
        }
    }

}
```
###### \java\seedu\taskmanager\logic\commands\UndoCommand.java
``` java
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Undo last action that led to a change in Todo list"
            + "Example: " + COMMAND_WORD;

    public static final String MESSAGE_DONE_SUCCESS = "Undo last action: %1$s";
    public static final String MESSAGE_DONE_FAILURE = "Cannot Undo";

    /*
     * Undo last command that led to a change in todo list.
     */
    public UndoCommand() {
    	
    }

    @Override
    public CommandResult execute() {

        String done = model.undoAction();
        // model.updateFilteredListToShowAll();
        if (done != null) {
            return new CommandResult(String.format(MESSAGE_DONE_SUCCESS, done));
        } else {
            return new CommandResult(MESSAGE_DONE_FAILURE);
        }
    }

}
```
###### \java\seedu\taskmanager\logic\parser\Parser.java
``` java
    private static final Pattern TASK_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("(T|t)((A|a)(S|s)(K|k))?\\s*"
                    + "(n/)?(?<name>[^/]+)"
                    + "(?<tagArguments>(?: #[^/#]+)*)"); // variable number of tags

    private static final Pattern DEADLINE_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("(D|d)((E|e)(A|a)(D|d)(L|l)(I|i)(N|n)(E|e))?\\s*"
                    + "(n/)?(?<name>[^/]+)"
                    + END_DATE_ARG_FORMAT
                    + END_TIME_ARG_FORMAT + "?"
                    + "(?<tagArguments>(?: #[^/#]+)*)"); // variable number of tags

    private static final Pattern EVENT_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("(E|e)((V|v)(E|e)(N|n)(T|t))?\\s*"
                    + "(n/)?(?<name>[^/]+)"
            		+ START_DATE_ARG_FORMAT
                    + START_TIME_ARG_FORMAT + "?"
                    + END_DATE_ARG_FORMAT
                    + END_TIME_ARG_FORMAT + "?"
                    + "(?<tagArguments>(?: #[^/#]+)*)"); // variable number of tags
    
    private static final Pattern DEADLINE_NLP_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("(D|d)((E|e)(A|a)(D|d)(L|l)(I|i)(N|n)(E|e))?\\s*"
                    + "(n/)?(?<name>[^/]+)"
                    + END_DATETIME_ARG_FORMAT
                    + "(?<tagArguments>(?: #[^/#]+)*)"); // variable number of tags

    private static final Pattern EVENT_NLP_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("(E|e)((V|v)(E|e)(N|n)(T|t))?\\s*"
                    + "(n/)?(?<name>[^/]+)"
            		+ START_DATETIME_ARG_FORMAT
                    + END_DATETIME_ARG_FORMAT
                    + "(?<tagArguments>(?: #[^/#]+)*)"); // variable number of tags
    
```
###### \java\seedu\taskmanager\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the add item command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareAdd(String args){
        final Matcher taskMatcher = ADD_TASK_COMMAND_ARGS_FORMAT.matcher(args.trim());
        final Matcher deadlineMatcher = ADD_DEADLINE_COMMAND_ARGS_FORMAT.matcher(args.trim());
        final Matcher eventMatcher = ADD_EVENT_COMMAND_ARGS_FORMAT.matcher(args.trim());
        
        if (taskMatcher.matches()) {
        	try {
		    	return addTask(taskMatcher);
		    } catch (IllegalValueException e) {
		        e.printStackTrace();
		    }
        } else if (deadlineMatcher.matches()) {
            try {
		    	return addDeadline(deadlineMatcher);
		    } catch (IllegalValueException e) {
		        e.printStackTrace();
		    }
        } else if (eventMatcher.matches()) {
            try {
		        return addEvent(eventMatcher);
		    } catch (IllegalValueException e) {
		        e.printStackTrace();
		    }
        } else {
        	return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
        return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
    }
    
    private Command addNlpEvent(final Matcher eventNlpMatcher) throws IllegalValueException {
    	String addCommandArgs = eventNlpMatcher.group("addCommandArguments");
    	ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(namePrefix, startDateTimePrefix, endDateTimePrefix, tagPrefix);
    	argsTokenizer.tokenize(addCommandArgs);
        String name = getParsedArgumentFromArgumentTokenizerWithoutOptional(argsTokenizer, namePrefix);
        String startDateTime = getParsedArgumentFromArgumentTokenizerWithoutOptional(argsTokenizer, startDateTimePrefix);
        String endDateTime = getParsedArgumentFromArgumentTokenizerWithoutOptional(argsTokenizer, endDateTimePrefix);
        if (name == null || startDateTime == null || endDateTime == null) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
        List<String> tagsToAdd = getParsedTagsToAddFromArgumentTokenizerWithoutOptional(argsTokenizer, tagPrefix);
        if (tagsToAdd == null) {
            tagsToAdd = new ArrayList<String>();
        }

        List<Date> startDateTimes = new PrettyTimeParser().parse(startDateTime); 
        List<Date> endDateTimes = new PrettyTimeParser().parse(endDateTime);
        // Just Take First Value for Start and End
        if (startDateTimes.isEmpty() || endDateTimes.isEmpty()) {
        	return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_DATETIME_PARSE_FAILURE));
        }
        Date processedStartDateTime = startDateTimes.get(0);
        Date processedEndDateTime = endDateTimes.get(0);
        if (processedEndDateTime.before(processedStartDateTime)) {
	        return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, Command.MESSAGE_END_DATE_TIME_BEFORE_START_DATE_TIME));
	    }
        SimpleDateFormat dateFormat = new SimpleDateFormat(ItemDate.DATE_FORMAT);
        SimpleDateFormat timeFormat = new SimpleDateFormat("HH:mm");
        String startDate = dateFormat.format(processedStartDateTime);
        String startTime = timeFormat.format(processedStartDateTime);
        String endDate = dateFormat.format(processedEndDateTime);
        String endTime = timeFormat.format(processedEndDateTime);
    	return new AddCommand(ItemType.EVENT_WORD,
                name, 
                startDate, 
                startTime, 
                endDate, 
                endTime, 
                tagsToAdd);
    }
    
    private Command addNlpDeadline(final Matcher deadlineNlpMatcher) throws IllegalValueException {
    	String addCommandArgs = deadlineNlpMatcher.group("addCommandArguments");
    	ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(namePrefix, endDateTimePrefix, tagPrefix);
        argsTokenizer.tokenize(addCommandArgs);
        String name = getParsedArgumentFromArgumentTokenizerWithoutOptional(argsTokenizer, namePrefix);
        String endDateTime = getParsedArgumentFromArgumentTokenizerWithoutOptional(argsTokenizer, endDateTimePrefix);
        if (name == null || endDateTime == null) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
        List<String> tagsToAdd = getParsedTagsToAddFromArgumentTokenizerWithoutOptional(argsTokenizer, tagPrefix);
        if (tagsToAdd == null) {
            tagsToAdd = new ArrayList<String>();
        }
        
        List<Date> endDateTimes = new PrettyTimeParser().parse(endDateTime);
        // Just Take First Value for Start and End
        if (endDateTimes.isEmpty()) {
        	return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_DATETIME_PARSE_FAILURE));
        }
        Date processedEndDateTime = endDateTimes.get(0);
        SimpleDateFormat dateFormat = new SimpleDateFormat(ItemDate.DATE_FORMAT);
        SimpleDateFormat timeFormat = new SimpleDateFormat("HH:mm");
        String endDate = dateFormat.format(processedEndDateTime);
        String endTime = timeFormat.format(processedEndDateTime);
    	return new AddCommand(ItemType.DEADLINE_WORD,
                name,
                endDate, 
                endTime, 
                tagsToAdd);
    }

	private Command addEvent(final Matcher eventMatcher) throws IllegalValueException {
        String addCommandArgs = eventMatcher.group("addCommandArguments");
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(namePrefix, endDatePrefix, endTimePrefix,
                                                                endDateTimePrefix, startDatePrefix, startTimePrefix,
                                                                startDateTimePrefix, tagPrefix);
        argsTokenizer.tokenize(addCommandArgs);
        
        //Capture argument values into their respective variables if available
        String name = getParsedArgumentFromArgumentTokenizerWithoutOptional(argsTokenizer, namePrefix);
        String endDate = getParsedArgumentFromArgumentTokenizerWithoutOptional(argsTokenizer, endDatePrefix);
        String endTime = getParsedArgumentFromArgumentTokenizerWithoutOptional(argsTokenizer, endTimePrefix);
        String endDateTime = getParsedArgumentFromArgumentTokenizerWithoutOptional(argsTokenizer, endDateTimePrefix);
        String startDate = getParsedArgumentFromArgumentTokenizerWithoutOptional(argsTokenizer, startDatePrefix);
        String startTime = getParsedArgumentFromArgumentTokenizerWithoutOptional(argsTokenizer, startTimePrefix);
        String startDateTime = getParsedArgumentFromArgumentTokenizerWithoutOptional(argsTokenizer, startDateTimePrefix);
        List<String> tagsToAdd = getParsedTagsToAddFromArgumentTokenizerWithoutOptional(argsTokenizer, tagPrefix);
        if (tagsToAdd == null) {
            tagsToAdd = new ArrayList<String>();
        }
        if (containsInput(endDateTime) || containsInput(startDateTime)) {
        	return addNlpEvent(eventMatcher);
        } else {
        	if (name == null || startDate == null || endDate == null) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
            }
        	try { 
            	SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd hh:mm");
        		SimpleDateFormat df = new SimpleDateFormat(ItemDate.DATE_FORMAT);
        		try {
        		    df.setLenient(false);
        		    // If yyyy-MM-dd
        		    String startDateString;
        		    String endDateString;
        		    String[] parts = endDate.split("-");
        		    if (parts.length == 3) {
        		        endDateString = endDate;
        		        df.parse(endDate);
        		    } else { // MM-dd
        		        LocalDateTime ldt = LocalDateTime.now();
        		        endDateString = ldt.getYear() + "-" + endDate;
        		        df.parse(endDateString);
        		    }
        		    String[] parts2 = startDate.split("-");
        		    // If yyyy-MM-dd
        		    if (parts2.length == 3) {
        		        startDateString = startDate;
        		        df.parse(startDate);
        		    } else { // MM-dd
        		        LocalDateTime ldt = LocalDateTime.now();
        		        startDateString = ldt.getYear() + "-" + startDate;
        		        df.parse(startDateString);
        		    }
        		    if (endTime == null) {
        		        endTime = AddCommand.DEFAULT_END_TIME;
        		    }
        		    if (startTime == null) {
        		        startTime = AddCommand.DEFAULT_START_TIME;
        		    }
        		    if (sdf.parse(endDateString + " " + endTime).before(sdf.parse(startDateString + " " + startTime))) {
        		        return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, Command.MESSAGE_END_DATE_TIME_BEFORE_START_DATE_TIME));
        		    } else {
	        		    return new AddCommand(ItemType.EVENT_WORD, 
	    	                      name, 
	    	                      startDate, 
	    	                      startTime, 
	    	                      endDate, 
	    	                      endTime, 
	    	                      tagsToAdd);
        		    }
        		} catch (ParseException e) {
        		    return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ItemDate.MESSAGE_DATE_CONSTRAINTS));
        		}
            } catch (IllegalValueException ive) {
                return new IncorrectCommand(ive.getMessage());
            }
        }
	}

	private Command addDeadline(final Matcher deadlineMatcher) throws IllegalValueException {
        String addCommandArgs = deadlineMatcher.group("addCommandArguments");
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(namePrefix, endDatePrefix, endTimePrefix,
                                                                endDateTimePrefix, tagPrefix);
        argsTokenizer.tokenize(addCommandArgs);
        
        //Capture argument values into their respective variables if available
        String name = getParsedArgumentFromArgumentTokenizerWithoutOptional(argsTokenizer, namePrefix);
        String endDate = getParsedArgumentFromArgumentTokenizerWithoutOptional(argsTokenizer, endDatePrefix);
        String endTime = getParsedArgumentFromArgumentTokenizerWithoutOptional(argsTokenizer, endTimePrefix);
        String endDateTime = getParsedArgumentFromArgumentTokenizerWithoutOptional(argsTokenizer, endDateTimePrefix);
        List<String> tagsToAdd = getParsedTagsToAddFromArgumentTokenizerWithoutOptional(argsTokenizer, tagPrefix);
        if (tagsToAdd == null) {
            tagsToAdd = new ArrayList<String>();
        }
        
        try {
            //Handle case where user enters end date and time using natural language via edt/
            if (containsInput(endDateTime)) {
                return addNlpDeadline(deadlineMatcher);
            } else {
            	if (name == null || endDate == null) {
                    return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
                }
        	    try {
                    SimpleDateFormat df = new SimpleDateFormat(ItemDate.DATE_FORMAT);
                    SimpleDateFormat df2 = new SimpleDateFormat(ItemDate.ALTERNATE_DATE_FORMAT);
                    df.setLenient(false);
                    String[] parts = endDate.split("-");
                    // If yyyy-MM-dd
                    if (parts.length == 3) {
                        df.parse(endDate);
                    } else { // MM-dd
                        df2.parse(endDate);
                    }
                } catch (ParseException e) {
                    return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ItemDate.MESSAGE_DATE_CONSTRAINTS));
                }
                return new AddCommand(ItemType.DEADLINE_WORD,
                                      name, 
                                      endDate,
                                      endTime,
                                      tagsToAdd);
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
	
	private Command addTask(final Matcher taskDeadline) throws IllegalValueException {
		String addCommandArgs = taskDeadline.group("addCommandArguments");
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(namePrefix, tagPrefix);
        argsTokenizer.tokenize(addCommandArgs);
        
        //Capture argument values into their respective variables if available
        String name = getParsedArgumentFromArgumentTokenizerWithoutOptional(argsTokenizer, namePrefix);
        if (name == null) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
        List<String> tagsToAdd = getParsedTagsToAddFromArgumentTokenizerWithoutOptional(argsTokenizer, tagPrefix);
        if (tagsToAdd == null) {
            tagsToAdd = new ArrayList<String>();
        }
        return new AddCommand(ItemType.TASK_WORD,
                              name,
                              tagsToAdd);
    }
```
###### \java\seedu\taskmanager\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the done item command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareDone(String args) {

        Optional<Integer> index = parseIndex(args);
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DoneCommand.MESSAGE_USAGE));
        }

        return new DoneCommand(index.get());
    }

    /**
     * Parses arguments in the context of the not done item command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareNotDone(String args) {

        Optional<Integer> index = parseIndex(args);
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DoneCommand.MESSAGE_USAGE));
        }

        return new NotDoneCommand(index.get());
    }    
    
```
###### \java\seedu\taskmanager\model\item\ItemDate.java
``` java
    
    /**
     * Validates given date.
     *
     * @throws IllegalValueException if given date string is invalid.
     */
    public ItemDate(String date) throws IllegalValueException {
        assert date != null;
        date = date.trim();
        if (date != null && !date.isEmpty()) {
            String parts[] = date.split("-");
            // If only MM-dd
            if (parts.length < 3) {
                // Try adding year in front
                LocalDateTime ldt = LocalDateTime.now();
                date = ldt.getYear() + "-" + date;
            }
        }
        if (!isValidDate(date)) {
            throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS);
        }
        this.value = date;
    }

    /**
     * Returns if a given string is a valid date.
     */
    public static boolean isValidDate(String test) {
    	if (test.equals(EMPTY_DATE)) {
    		return true;
    	}
        return test.matches(DATE_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ItemDate // instanceof handles nulls
                && this.value.equals(((ItemDate) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### \java\seedu\taskmanager\model\item\ItemTime.java
``` java
    
    /**
     * Validates given time.
     *
     * @throws IllegalValueException if given time string is invalid.
     */
    public ItemTime(String time) throws IllegalValueException {
        assert time != null;
        time = time.trim();
        if (!isValidTime(time)) {
            throw new IllegalValueException(MESSAGE_TIME_CONSTRAINTS);
        }
        this.value = time;
    }

    /**
     * Returns true if a given string is a valid time.
     */
    public static boolean isValidTime(String test) {
    	if (test.equals(EMPTY_TIME)) {
    		return true;
    	}
        return test.matches(TIME_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ItemTime // instanceof handles nulls
                && this.value.equals(((ItemTime) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### \java\seedu\taskmanager\model\ModelManager.java
``` java
    @Override
    public synchronized void setDone(ReadOnlyItem target, String actionTaken) throws ItemNotFoundException {
        taskManager.setDone(target);
        raise(new ChangeDoneEvent());
        indicateTaskManagerChanged(actionTaken);
    }
    
    @Override
    public synchronized void setUndone(ReadOnlyItem target, String actionTaken) throws ItemNotFoundException {
        taskManager.setUndone(target);
        raise(new ChangeDoneEvent());
        indicateTaskManagerChanged(actionTaken);
    }

    /** Raises an event to indicate the model has changed */
    private void indicateTaskManagerChanged(String actionTaken) {
        ReadOnlyTaskManager newData = new TaskManager(taskManager);
        HistoryTaskManager newHistory = new HistoryTaskManager(newData, actionTaken);
        history.push(newHistory);
        undoneHistory.clear();
        raise(new TaskManagerChangedEvent(taskManager));
        raise(new FilterEvent(filteredItems));
    }
    
    /** Raises an event to indicate the model has changed because of a redo function */
    private void indicateTaskManagerRedo(String actionTaken) {
        ReadOnlyTaskManager newData = new TaskManager(taskManager);
        HistoryTaskManager newHistory = new HistoryTaskManager(newData, actionTaken);
        history.push(newHistory);
        raise(new TaskManagerChangedEvent(taskManager));
        raise(new FilterEvent(filteredItems));
    }
    
    @Override
    public String undoAction() {
    	if (history.empty()) {
    	    return null;
    	} else {
            HistoryTaskManager currentData = history.pop();
            if (history.empty()) {
                history.push(currentData);
            	return null;
            } else {
            	HistoryTaskManager oldData = history.pop();
            	undoneHistory.push(currentData);
                taskManager.resetData(oldData.getPastTaskManager());
                indicateTaskManagerRedo(oldData.getActionTaken());
                return currentData.getActionTaken();
            }
    	}
    }
    
    @Override
    public String redoAction() {
    	if (undoneHistory.empty()) {
    	    return null;
    	} else {
            HistoryTaskManager currentData = undoneHistory.pop();
            taskManager.resetData(currentData.getPastTaskManager());
            indicateTaskManagerRedo(currentData.getActionTaken());
            return currentData.getActionTaken();
    	}
    }
    
```
###### \java\seedu\taskmanager\model\ModelManager.java
``` java
    private class HistoryTaskManager {
        
        private String actionTaken;
        private ReadOnlyTaskManager pastTaskManager;
        
        HistoryTaskManager(TaskManager pastTaskManager, String actionTaken) {
        	this.pastTaskManager = pastTaskManager;
            this.actionTaken = actionTaken;
		}

		HistoryTaskManager(ReadOnlyTaskManager pastTaskManager, String actionTaken) {
            this.pastTaskManager = pastTaskManager;
            this.actionTaken = actionTaken;
        }
        
        public String getActionTaken() {
            return actionTaken;
        }
        
        public ReadOnlyTaskManager getPastTaskManager() {
            return pastTaskManager;
        }
    }

```
###### \java\seedu\taskmanager\model\TaskManager.java
``` java
    /**
     * Set Item as done
     */
    public void setDone(ReadOnlyItem key) throws UniqueItemList.ItemNotFoundException {
        items.setDone(key);
    }
    
    /**
     * Set Item as undone
     */
    public void setUndone(ReadOnlyItem key) throws UniqueItemList.ItemNotFoundException {
        items.setUndone(key);
    }
    //@author

//// tag-level operations

    public void addTag(Tag t) throws UniqueTagList.DuplicateTagException {
        tags.add(t);
    }

//// util methods

    @Override
    public String toString() {
        return items.getInternalList().size() + " items, " + tags.getInternalList().size() +  " tags";
        // TODO: refine later
    }

    @Override
    public List<ReadOnlyItem> getItemList() {
        return Collections.unmodifiableList(items.getInternalList());
    }

    @Override
    public List<Tag> getTagList() {
        return Collections.unmodifiableList(tags.getInternalList());
    }

    @Override
    public UniqueItemList getUniqueItemList() {
        return this.items;
    }

    @Override
    public UniqueTagList getUniqueTagList() {
        return this.tags;
    }


    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskManager // instanceof handles nulls
                && this.items.equals(((TaskManager) other).items)
                && this.tags.equals(((TaskManager) other).tags));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(items, tags);
    }
}
```
###### \java\seedu\taskmanager\storage\XmlAdaptedItem.java
``` java
    @XmlElement(required = true)
    private String name;
    @XmlElement(required = true)
    private String itemType;
    @XmlElement(required = true)
    private String startDate;
    @XmlElement(required = true)
    private String startTime;
    @XmlElement(required = true)
    private String endDate;
    @XmlElement(required = true)
    private String endTime;
    @XmlElement(required = true)
    private boolean done;

    @XmlElement
    private List<XmlAdaptedTag> tagged = new ArrayList<>();

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedItem() {}


    /**
     * Converts a given Item into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedItem
     */
    public XmlAdaptedItem(ReadOnlyItem source) {
        name = source.getName().value;
        itemType = source.getItemType().value;
        startDate = source.getStartDate().value;
        startTime = source.getStartTime().value;
        endDate = source.getEndDate().value;
        endTime = source.getEndTime().value;
        done = source.getDone();
        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
    }

    /**
     * Converts this jaxb-friendly adapted item object into the model's Item object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted item
     */
    public Item toModelType() throws IllegalValueException {
        final List<Tag> itemTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            itemTags.add(tag.toModelType());
        }
        final ItemType itemType = new ItemType(this.itemType);
        final Name name = new Name(this.name);
        final ItemDate startDate = new ItemDate(this.startDate);
        final ItemTime startTime = new ItemTime(this.startTime);
        final ItemDate endDate = new ItemDate(this.endDate);
        final ItemTime endTime = new ItemTime(this.endTime);
        final UniqueTagList tags = new UniqueTagList(itemTags);
        return new Item(itemType, name, startDate, startTime, endDate, endTime, this.done, tags);
    }
}
```
###### \java\seedu\taskmanager\ui\ItemCard.java
``` java
    @FXML
    private Label itemType;
    @FXML
    private Label endTime;
    @FXML
    private Label endDate;
    @FXML
    private Label endFromNow;
    @FXML
    private Label startTime;
    @FXML
    private Label startDate;
    @FXML
    private Label tags;

    private ReadOnlyItem item;
    @FXML
    private Button doneButton;
    @FXML
    private Button deleteButton;

    private int displayedIndex;
    private Logic logic;
    public static final String DONE_TEXT = "Done";
    public static final String UNDONE_TEXT = "Not Done";
    
    @FXML
    public void doneButtonAction(ActionEvent event) {
        Button button = (Button) event.getSource();
        if (button.getText().equals(UNDONE_TEXT)) {
            button.setText(DONE_TEXT);
            logic.execute(DoneCommand.COMMAND_WORD + " " + displayedIndex);
        } else {
            button.setText(UNDONE_TEXT);
            logic.execute(NotDoneCommand.COMMAND_WORD + " " + displayedIndex);
        }
    }
    
    @FXML
    public void deleteButtonAction(ActionEvent event) {
        logic.execute(DeleteCommand.COMMAND_WORD + " " + displayedIndex);
    }

    public ItemCard(){

    }

    public static ItemCard load(ReadOnlyItem item, int displayedIndex, Logic logic){
        ItemCard card = new ItemCard();
        card.item = item;
        card.displayedIndex = displayedIndex;
        card.configure(logic);
        return UiPartLoader.loadUiPart(card);
    }
    
    public void configure(Logic logic) {
        this.logic = logic;
    }

    @FXML
    public void initialize() {
        name.setText(item.getName().value);
        itemType.setText(item.getItemType().value);
        endTime.setText(item.getEndTime().value);
        endDate.setText(item.getEndDate().value);
        String endDateString = item.getEndDate().value + " " + item.getEndTime().value;
        DateFormat df = new SimpleDateFormat("yyyy-MM-dd hh:mm"); 
        Date endFromNowDate;
        Date currentDate = new Date();
        String endFromNowText = "";
        if (item.getItemType().value.equals(ItemType.DEADLINE_WORD) || item.getItemType().value.equals(ItemType.EVENT_WORD)) {
            try {
                endFromNowDate = df.parse(endDateString);
                PrettyTime p = new PrettyTime();
                endFromNowText = p.format(endFromNowDate);
                if (currentDate.before(endFromNowDate)) { // Future Deadline
                    endFromNow.setText("Ends " + endFromNowText);
                } else { // Past Deadline
            	    endFromNow.setText("Ended " + endFromNowText);
                }
            } catch (ParseException e) {
                endFromNow.setText(endFromNowText);
                e.printStackTrace();
            }
        } else {
        	endFromNow.setText(endFromNowText);
        }
        startTime.setText(item.getStartTime().value);
        startDate.setText(item.getStartDate().value);
        tags.setText(item.tagsString());
        if (item.getDone()) {
            doneButton.setText(DONE_TEXT);
        } else {
        	doneButton.setText(UNDONE_TEXT);
        }
        tags.setText(item.tagsString());
    }

    public HBox getLayout() {
        return cardPane;
    }

    @Override
    public void setNode(Node node) {
        cardPane = (HBox)node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### \java\seedu\taskmanager\ui\ItemDetailsPanel.java
``` java
/**
 * Panel containing the list of items.
 */
public class ItemDetailsPanel extends UiPart {
    private final Logger logger = LogsCenter.getLogger(ItemDetailsPanel.class);
    private static final String FXML = "ItemDetailsPanel.fxml";
    private VBox panel;
    private AnchorPane placeHolderPane;
    private Logic logic;
    private ObservableList<ReadOnlyItem> itemList;
    private ArrayList<Integer> itemIndex;

    @FXML
    private ListView<ReadOnlyItem> itemListView;

    public ItemDetailsPanel() {
        super();
    }

    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    public static ItemDetailsPanel load(Stage primaryStage, AnchorPane itemListPlaceholder,
                                       Logic logic) {
        ItemDetailsPanel itemListPanel =
                UiPartLoader.loadUiPart(primaryStage, itemListPlaceholder, new ItemDetailsPanel());
        itemListPanel.configure();
        itemListPanel.logic = logic;
        itemListPanel.itemList = FXCollections.observableArrayList();
        itemListPanel.itemIndex = new ArrayList<Integer>();
        return itemListPanel;
    }

    private void configure() {
        addToPlaceholder();
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(panel);
    }

    class ItemListViewCell extends ListCell<ReadOnlyItem> {

        private ArrayList<Integer> allIndexes;
    	
        public ItemListViewCell(ArrayList<Integer> allIndexes) {
            this.allIndexes = allIndexes;
        }

        @Override
        protected void updateItem(ReadOnlyItem item, boolean empty) {
            super.updateItem(item, empty);

            if (empty || item == null) {
                setGraphic(null);
                setText(null);
            } else {
                if (allIndexes.size() > getIndex()) {
                    setGraphic(ItemCard.load(item, allIndexes.get(getIndex()), logic).getLayout());
                }
            }
        }
    }
    
	public void loadItem(ReadOnlyItem item, int newIdx) {
	    // Uncomment to add more than one item
		//if (itemList.contains(item)) {
	    //    int requiredIdx = itemList.indexOf(item);
	    //    itemList.remove(requiredIdx);
	    //    itemIndex.remove(requiredIdx);
	    //} else {
	    //    itemList.add(item);
	    //    itemIndex.add(newIdx+1);
	    //}
		itemList.clear();
		itemIndex.clear();
		itemList.add(item);
		itemIndex.add(newIdx+1);
	    itemListView.setItems(itemList);
        itemListView.setCellFactory(listView -> new ItemListViewCell(itemIndex));
	}

	public void freeResources() {
        itemList.clear();
        itemIndex.clear();
        itemListView.setItems(itemList);
        itemListView.setCellFactory(listView -> new ItemListViewCell(itemIndex));	    
	}
	
	public void filterItems(FilteredList<Item> filteredItems) {
		ArrayList<Integer> detailedItemsToDelete = new ArrayList<Integer>();
	    for (int i=0; i<itemList.size(); ++i) {
	    	ReadOnlyItem detailedItem = itemList.get(i);
	        if (filteredItems.contains(detailedItem)) {
	            int idx = filteredItems.indexOf(detailedItem);
	            itemIndex.set(i, idx+1);
	        } else {
	            detailedItemsToDelete.add(i);
	        }
	    }
	    Collections.sort(detailedItemsToDelete, Collections.reverseOrder());
		for (int i=0; i<detailedItemsToDelete.size(); ++i) {
		    int deleteIdx = detailedItemsToDelete.get(i);
		    itemIndex.remove(deleteIdx);
		    itemList.remove(deleteIdx);
		}
		itemListView.setItems(itemList);
        itemListView.setCellFactory(listView -> new ItemListViewCell(itemIndex));
	}

}
```
###### \java\seedu\taskmanager\ui\ShortItemCard.java
``` java
public class ShortItemCard extends UiPart{

    private static final String FXML = "ShortItemListCard.fxml";

    @FXML
    private HBox cardPane;
    @FXML
    private Label name;
    @FXML
    private Label id;
    @FXML
    private Label tags;

    private ReadOnlyItem item;
    @FXML
    private Button doneButton;
    @FXML
    private Button deleteButton;

    private int displayedIndex;
    private Logic logic;
    public static final String DONE_TEXT = "Done";
    public static final String UNDONE_TEXT = "Not Done";
    
    @FXML
    public void doneButtonAction(ActionEvent event) {
        Button button = (Button) event.getSource();
        if (button.getText().equals(UNDONE_TEXT)) {
            button.setText(DONE_TEXT);
            logic.execute(DoneCommand.COMMAND_WORD + " " + displayedIndex);
        } else {
            button.setText(UNDONE_TEXT);
            logic.execute(NotDoneCommand.COMMAND_WORD + " " + displayedIndex);
        }
    }
    
    @FXML
    public void deleteButtonAction(ActionEvent event) {
        logic.execute(DeleteCommand.COMMAND_WORD + " " + displayedIndex);
    }

    public ShortItemCard(){

    }

    public static ShortItemCard load(ReadOnlyItem item, int displayedIndex, Logic logic){
        ShortItemCard card = new ShortItemCard();
        card.item = item;
        card.displayedIndex = displayedIndex;
        card.configure(logic);
        return UiPartLoader.loadUiPart(card);
    }
    
    public void configure(Logic logic) {
        this.logic = logic;
    }

    @FXML
    public void initialize() {
        name.setText(item.getName().value);
        id.setText(displayedIndex + ". ");
        tags.setText(item.tagsString());
    }

    public HBox getLayout() {
        return cardPane;
    }

    @Override
    public void setNode(Node node) {
        cardPane = (HBox)node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### \java\seedu\taskmanager\ui\ShortItemListPanel.java
``` java
/**
 * Panel containing the list of items.
 */
public class ShortItemListPanel extends UiPart {
    private final Logger logger = LogsCenter.getLogger(ShortItemListPanel.class);
    private static final String FXML = "ShortItemListPanel.fxml";
    private VBox panel;
    private AnchorPane placeHolderPane;
    private Logic logic;

    @FXML
    private ListView<ReadOnlyItem> shortItemListView;

    public ShortItemListPanel() {
        super();
    }

    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
    
    @FXML 
    public void handleShortItemClick() {
        ReadOnlyItem newItem = shortItemListView.getSelectionModel().getSelectedItem();
        raise(new ShortItemPanelSelectionChangedEvent(newItem, shortItemListView.getItems().indexOf(newItem)));
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    public static ShortItemListPanel load(Stage primaryStage, AnchorPane shortItemListPlaceholder,
                                       ObservableList<ReadOnlyItem> itemList, Logic logic) {
        ShortItemListPanel itemListPanel =
                UiPartLoader.loadUiPart(primaryStage, shortItemListPlaceholder, new ShortItemListPanel());
        itemListPanel.configure(itemList);
        itemListPanel.logic = logic;
        return itemListPanel;
    }

    private void configure(ObservableList<ReadOnlyItem> itemList) {
        setConnections(itemList);
        addToPlaceholder();
    }

    private void setConnections(ObservableList<ReadOnlyItem> itemList) {
        shortItemListView.setItems(itemList);
        shortItemListView.setCellFactory(listView -> new ShortItemListViewCell());
        // setEventHandlerForSelectionChangeEvent();
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(panel);
    }

    private void setEventHandlerForSelectionChangeEvent() {
        shortItemListView.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
            if (newValue != null) {
                logger.fine("Selection in item list panel changed to : '" + newValue + "'");
                raise(new ShortItemPanelSelectionChangedEvent(newValue, shortItemListView.getItems().indexOf(newValue)));
            }
        });
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            shortItemListView.scrollTo(index);
            shortItemListView.getSelectionModel().clearAndSelect(index);
            handleShortItemClick();
        });
    }
    
    public void updateIndex() {
        shortItemListView.setCellFactory(listView -> new ShortItemListViewCell());
    }

    class ShortItemListViewCell extends ListCell<ReadOnlyItem> {

        public ShortItemListViewCell() {

        }

        @Override
        protected void updateItem(ReadOnlyItem item, boolean empty) {
            super.updateItem(item, empty);

            if (empty || item == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(ShortItemCard.load(item, getIndex() + 1, logic).getLayout());
            }
        }
    }

}
```
###### \java\seedu\taskmanager\ui\UiManager.java
``` java
    @Subscribe
    private void handleItemPanelSelectionChangedEvent(ShortItemPanelSelectionChangedEvent event){
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.loadItem(event.getNewSelection(), event.getNewIdx());
    }
    
    @Subscribe
    private void handleChangeDoneEvent(ChangeDoneEvent event) {
        // mainWindow.getShortItemListPanel().updateIndex();
        // mainWindow.getItemListPanel().freeResources();
    }
    
    @Subscribe
    private void handleFilterEvent(FilterEvent event) {
        // mainWindow.getShortItemListPanel().updateIndex();
        mainWindow.filterItems(event.getFilteredItems());
    }

}
```
